// Copyright (c) 2012, 2013 Ugorji Nwoke. All rights reserved.
// Use of this source code is governed by a BSD-style license found in the LICENSE file.

// ************************************************************
// DO NOT EDIT.
// THIS FILE IS GENERATED BY RUNNING: go run gen-fast-path.go
// ************************************************************

package codec

// Fast path functions try to create a fast path encode or decode implementation
// for common maps and slices.
//
// We define the functions and register then in this single file
// so as not to pollute the encode.go and decode.go, and create a dependency in there.
// This file can be omitted without causing a build failure.
//
// The advantage of fast paths is:
//    - Many calls bypass reflection altogether
//
// Currently support
//    - slice of all builtin types,
//    - map of all builtin types to string or interface value
//    - symetrical maps of all builtin types (e.g. str-str, uint8-uint8)
// This should provide adequate "typical" implementations.

import (
	"reflect"
)

func init() {
	if !fastpathEnabled {
		return // basically disable the fast path checks (since accessing empty map is basically free)
	}
	fdx := func(i interface{}, fd func(*decFnInfo, reflect.Value)) {
		fastpathsDec[reflect.ValueOf(reflect.TypeOf(i)).Pointer()] = fd
	}
	fex := func(i interface{}, fe func(*encFnInfo, reflect.Value)) {
		fastpathsEnc[reflect.ValueOf(reflect.TypeOf(i)).Pointer()] = fe
	}

	fex([]interface{}(nil), (*encFnInfo).fastEncSliceIntf)
	fex([]string(nil), (*encFnInfo).fastEncSliceString)
	fex([]float32(nil), (*encFnInfo).fastEncSliceFloat32)
	fex([]float64(nil), (*encFnInfo).fastEncSliceFloat64)
	fex([]uint(nil), (*encFnInfo).fastEncSliceUint)
	fex([]uint16(nil), (*encFnInfo).fastEncSliceUint16)
	fex([]uint32(nil), (*encFnInfo).fastEncSliceUint32)
	fex([]uint64(nil), (*encFnInfo).fastEncSliceUint64)
	fex([]int(nil), (*encFnInfo).fastEncSliceInt)
	fex([]int8(nil), (*encFnInfo).fastEncSliceInt8)
	fex([]int16(nil), (*encFnInfo).fastEncSliceInt16)
	fex([]int32(nil), (*encFnInfo).fastEncSliceInt32)
	fex([]int64(nil), (*encFnInfo).fastEncSliceInt64)
	fex([]bool(nil), (*encFnInfo).fastEncSliceBool)

	fex(map[interface{}]interface{}(nil), (*encFnInfo).fastEncMapIntfIntf)
	fex(map[interface{}]string(nil), (*encFnInfo).fastEncMapIntfString)
	fex(map[string]interface{}(nil), (*encFnInfo).fastEncMapStringIntf)
	fex(map[string]string(nil), (*encFnInfo).fastEncMapStringString)
	fex(map[float32]interface{}(nil), (*encFnInfo).fastEncMapFloat32Intf)
	fex(map[float32]string(nil), (*encFnInfo).fastEncMapFloat32String)
	fex(map[float32]float32(nil), (*encFnInfo).fastEncMapFloat32Float32)
	fex(map[float64]interface{}(nil), (*encFnInfo).fastEncMapFloat64Intf)
	fex(map[float64]string(nil), (*encFnInfo).fastEncMapFloat64String)
	fex(map[float64]float64(nil), (*encFnInfo).fastEncMapFloat64Float64)
	fex(map[uint]interface{}(nil), (*encFnInfo).fastEncMapUintIntf)
	fex(map[uint]string(nil), (*encFnInfo).fastEncMapUintString)
	fex(map[uint]uint(nil), (*encFnInfo).fastEncMapUintUint)
	fex(map[uint8]interface{}(nil), (*encFnInfo).fastEncMapUint8Intf)
	fex(map[uint8]string(nil), (*encFnInfo).fastEncMapUint8String)
	fex(map[uint8]uint8(nil), (*encFnInfo).fastEncMapUint8Uint8)
	fex(map[uint16]interface{}(nil), (*encFnInfo).fastEncMapUint16Intf)
	fex(map[uint16]string(nil), (*encFnInfo).fastEncMapUint16String)
	fex(map[uint16]uint16(nil), (*encFnInfo).fastEncMapUint16Uint16)
	fex(map[uint32]interface{}(nil), (*encFnInfo).fastEncMapUint32Intf)
	fex(map[uint32]string(nil), (*encFnInfo).fastEncMapUint32String)
	fex(map[uint32]uint32(nil), (*encFnInfo).fastEncMapUint32Uint32)
	fex(map[uint64]interface{}(nil), (*encFnInfo).fastEncMapUint64Intf)
	fex(map[uint64]string(nil), (*encFnInfo).fastEncMapUint64String)
	fex(map[uint64]uint64(nil), (*encFnInfo).fastEncMapUint64Uint64)
	fex(map[int]interface{}(nil), (*encFnInfo).fastEncMapIntIntf)
	fex(map[int]string(nil), (*encFnInfo).fastEncMapIntString)
	fex(map[int]int(nil), (*encFnInfo).fastEncMapIntInt)
	fex(map[int8]interface{}(nil), (*encFnInfo).fastEncMapInt8Intf)
	fex(map[int8]string(nil), (*encFnInfo).fastEncMapInt8String)
	fex(map[int8]int8(nil), (*encFnInfo).fastEncMapInt8Int8)
	fex(map[int16]interface{}(nil), (*encFnInfo).fastEncMapInt16Intf)
	fex(map[int16]string(nil), (*encFnInfo).fastEncMapInt16String)
	fex(map[int16]int16(nil), (*encFnInfo).fastEncMapInt16Int16)
	fex(map[int32]interface{}(nil), (*encFnInfo).fastEncMapInt32Intf)
	fex(map[int32]string(nil), (*encFnInfo).fastEncMapInt32String)
	fex(map[int32]int32(nil), (*encFnInfo).fastEncMapInt32Int32)
	fex(map[int64]interface{}(nil), (*encFnInfo).fastEncMapInt64Intf)
	fex(map[int64]string(nil), (*encFnInfo).fastEncMapInt64String)
	fex(map[int64]int64(nil), (*encFnInfo).fastEncMapInt64Int64)
	fex(map[bool]interface{}(nil), (*encFnInfo).fastEncMapBoolIntf)
	fex(map[bool]string(nil), (*encFnInfo).fastEncMapBoolString)
	fex(map[bool]bool(nil), (*encFnInfo).fastEncMapBoolBool)

	fdx([]interface{}(nil), (*decFnInfo).fastDecSliceIntf)
	fdx([]string(nil), (*decFnInfo).fastDecSliceString)
	fdx([]float32(nil), (*decFnInfo).fastDecSliceFloat32)
	fdx([]float64(nil), (*decFnInfo).fastDecSliceFloat64)
	fdx([]uint(nil), (*decFnInfo).fastDecSliceUint)
	fdx([]uint16(nil), (*decFnInfo).fastDecSliceUint16)
	fdx([]uint32(nil), (*decFnInfo).fastDecSliceUint32)
	fdx([]uint64(nil), (*decFnInfo).fastDecSliceUint64)
	fdx([]int(nil), (*decFnInfo).fastDecSliceInt)
	fdx([]int8(nil), (*decFnInfo).fastDecSliceInt8)
	fdx([]int16(nil), (*decFnInfo).fastDecSliceInt16)
	fdx([]int32(nil), (*decFnInfo).fastDecSliceInt32)
	fdx([]int64(nil), (*decFnInfo).fastDecSliceInt64)
	fdx([]bool(nil), (*decFnInfo).fastDecSliceBool)

	fdx(map[interface{}]interface{}(nil), (*decFnInfo).fastDecMapIntfIntf)
	fdx(map[interface{}]string(nil), (*decFnInfo).fastDecMapIntfString)
	fdx(map[string]interface{}(nil), (*decFnInfo).fastDecMapStringIntf)
	fdx(map[string]string(nil), (*decFnInfo).fastDecMapStringString)
	fdx(map[float32]interface{}(nil), (*decFnInfo).fastDecMapFloat32Intf)
	fdx(map[float32]string(nil), (*decFnInfo).fastDecMapFloat32String)
	fdx(map[float32]float32(nil), (*decFnInfo).fastDecMapFloat32Float32)
	fdx(map[float64]interface{}(nil), (*decFnInfo).fastDecMapFloat64Intf)
	fdx(map[float64]string(nil), (*decFnInfo).fastDecMapFloat64String)
	fdx(map[float64]float64(nil), (*decFnInfo).fastDecMapFloat64Float64)
	fdx(map[uint]interface{}(nil), (*decFnInfo).fastDecMapUintIntf)
	fdx(map[uint]string(nil), (*decFnInfo).fastDecMapUintString)
	fdx(map[uint]uint(nil), (*decFnInfo).fastDecMapUintUint)
	fdx(map[uint8]interface{}(nil), (*decFnInfo).fastDecMapUint8Intf)
	fdx(map[uint8]string(nil), (*decFnInfo).fastDecMapUint8String)
	fdx(map[uint8]uint8(nil), (*decFnInfo).fastDecMapUint8Uint8)
	fdx(map[uint16]interface{}(nil), (*decFnInfo).fastDecMapUint16Intf)
	fdx(map[uint16]string(nil), (*decFnInfo).fastDecMapUint16String)
	fdx(map[uint16]uint16(nil), (*decFnInfo).fastDecMapUint16Uint16)
	fdx(map[uint32]interface{}(nil), (*decFnInfo).fastDecMapUint32Intf)
	fdx(map[uint32]string(nil), (*decFnInfo).fastDecMapUint32String)
	fdx(map[uint32]uint32(nil), (*decFnInfo).fastDecMapUint32Uint32)
	fdx(map[uint64]interface{}(nil), (*decFnInfo).fastDecMapUint64Intf)
	fdx(map[uint64]string(nil), (*decFnInfo).fastDecMapUint64String)
	fdx(map[uint64]uint64(nil), (*decFnInfo).fastDecMapUint64Uint64)
	fdx(map[int]interface{}(nil), (*decFnInfo).fastDecMapIntIntf)
	fdx(map[int]string(nil), (*decFnInfo).fastDecMapIntString)
	fdx(map[int]int(nil), (*decFnInfo).fastDecMapIntInt)
	fdx(map[int8]interface{}(nil), (*decFnInfo).fastDecMapInt8Intf)
	fdx(map[int8]string(nil), (*decFnInfo).fastDecMapInt8String)
	fdx(map[int8]int8(nil), (*decFnInfo).fastDecMapInt8Int8)
	fdx(map[int16]interface{}(nil), (*decFnInfo).fastDecMapInt16Intf)
	fdx(map[int16]string(nil), (*decFnInfo).fastDecMapInt16String)
	fdx(map[int16]int16(nil), (*decFnInfo).fastDecMapInt16Int16)
	fdx(map[int32]interface{}(nil), (*decFnInfo).fastDecMapInt32Intf)
	fdx(map[int32]string(nil), (*decFnInfo).fastDecMapInt32String)
	fdx(map[int32]int32(nil), (*decFnInfo).fastDecMapInt32Int32)
	fdx(map[int64]interface{}(nil), (*decFnInfo).fastDecMapInt64Intf)
	fdx(map[int64]string(nil), (*decFnInfo).fastDecMapInt64String)
	fdx(map[int64]int64(nil), (*decFnInfo).fastDecMapInt64Int64)
	fdx(map[bool]interface{}(nil), (*decFnInfo).fastDecMapBoolIntf)
	fdx(map[bool]string(nil), (*decFnInfo).fastDecMapBoolString)
	fdx(map[bool]bool(nil), (*decFnInfo).fastDecMapBoolBool)

}

// -- encode

func (f *encFnInfo) fastEncSliceIntf(rv reflect.Value) {
	v := rv.Interface().([]interface{})
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncSliceString(rv reflect.Value) {
	v := rv.Interface().([]string)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncSliceFloat32(rv reflect.Value) {
	v := rv.Interface().([]float32)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeFloat32(v2)
	}
}

func (f *encFnInfo) fastEncSliceFloat64(rv reflect.Value) {
	v := rv.Interface().([]float64)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeFloat64(v2)
	}
}

func (f *encFnInfo) fastEncSliceUint(rv reflect.Value) {
	v := rv.Interface().([]uint)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeUint(uint64(v2))
	}
}

func (f *encFnInfo) fastEncSliceUint16(rv reflect.Value) {
	v := rv.Interface().([]uint16)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeUint(uint64(v2))
	}
}

func (f *encFnInfo) fastEncSliceUint32(rv reflect.Value) {
	v := rv.Interface().([]uint32)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncSliceUint64(rv reflect.Value) {
	v := rv.Interface().([]uint64)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeUint(uint64(v2))
	}
}

func (f *encFnInfo) fastEncSliceInt(rv reflect.Value) {
	v := rv.Interface().([]int)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeInt(int64(v2))
	}
}

func (f *encFnInfo) fastEncSliceInt8(rv reflect.Value) {
	v := rv.Interface().([]int8)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeInt(int64(v2))
	}
}

func (f *encFnInfo) fastEncSliceInt16(rv reflect.Value) {
	v := rv.Interface().([]int16)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeInt(int64(v2))
	}
}

func (f *encFnInfo) fastEncSliceInt32(rv reflect.Value) {
	v := rv.Interface().([]int32)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncSliceInt64(rv reflect.Value) {
	v := rv.Interface().([]int64)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeInt(int64(v2))
	}
}

func (f *encFnInfo) fastEncSliceBool(rv reflect.Value) {
	v := rv.Interface().([]bool)
	f.ee.encodeArrayPreamble(len(v))
	for _, v2 := range v {
		f.ee.encodeBool(v2)
	}
}

func (f *encFnInfo) fastEncMapIntfIntf(rv reflect.Value) {
	v := rv.Interface().(map[interface{}]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.e.encode(k2)
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapIntfString(rv reflect.Value) {
	v := rv.Interface().(map[interface{}]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.e.encode(k2)
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapStringIntf(rv reflect.Value) {
	v := rv.Interface().(map[string]interface{})
	f.ee.encodeMapPreamble(len(v))
	asSymbols := f.e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	for k2, v2 := range v {
		if asSymbols {
			f.ee.encodeSymbol(k2)
		} else {
			f.ee.encodeString(c_UTF8, k2)
		}
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapStringString(rv reflect.Value) {
	v := rv.Interface().(map[string]string)
	f.ee.encodeMapPreamble(len(v))
	asSymbols := f.e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
	for k2, v2 := range v {
		if asSymbols {
			f.ee.encodeSymbol(k2)
		} else {
			f.ee.encodeString(c_UTF8, k2)
		}
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapFloat32Intf(rv reflect.Value) {
	v := rv.Interface().(map[float32]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeFloat32(k2)
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapFloat32String(rv reflect.Value) {
	v := rv.Interface().(map[float32]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeFloat32(k2)
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapFloat32Float32(rv reflect.Value) {
	v := rv.Interface().(map[float32]float32)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeFloat32(k2)
		f.ee.encodeFloat32(v2)
	}
}

func (f *encFnInfo) fastEncMapFloat64Intf(rv reflect.Value) {
	v := rv.Interface().(map[float64]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeFloat64(k2)
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapFloat64String(rv reflect.Value) {
	v := rv.Interface().(map[float64]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeFloat64(k2)
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapFloat64Float64(rv reflect.Value) {
	v := rv.Interface().(map[float64]float64)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeFloat64(k2)
		f.ee.encodeFloat64(v2)
	}
}

func (f *encFnInfo) fastEncMapUintIntf(rv reflect.Value) {
	v := rv.Interface().(map[uint]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapUintString(rv reflect.Value) {
	v := rv.Interface().(map[uint]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapUintUint(rv reflect.Value) {
	v := rv.Interface().(map[uint]uint)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.ee.encodeUint(uint64(v2))
	}
}

func (f *encFnInfo) fastEncMapUint8Intf(rv reflect.Value) {
	v := rv.Interface().(map[uint8]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapUint8String(rv reflect.Value) {
	v := rv.Interface().(map[uint8]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapUint8Uint8(rv reflect.Value) {
	v := rv.Interface().(map[uint8]uint8)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.ee.encodeUint(uint64(v2))
	}
}

func (f *encFnInfo) fastEncMapUint16Intf(rv reflect.Value) {
	v := rv.Interface().(map[uint16]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapUint16String(rv reflect.Value) {
	v := rv.Interface().(map[uint16]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapUint16Uint16(rv reflect.Value) {
	v := rv.Interface().(map[uint16]uint16)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.ee.encodeUint(uint64(v2))
	}
}

func (f *encFnInfo) fastEncMapUint32Intf(rv reflect.Value) {
	v := rv.Interface().(map[uint32]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.e.encode(k2)
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapUint32String(rv reflect.Value) {
	v := rv.Interface().(map[uint32]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.e.encode(k2)
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapUint32Uint32(rv reflect.Value) {
	v := rv.Interface().(map[uint32]uint32)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.e.encode(k2)
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapUint64Intf(rv reflect.Value) {
	v := rv.Interface().(map[uint64]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapUint64String(rv reflect.Value) {
	v := rv.Interface().(map[uint64]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapUint64Uint64(rv reflect.Value) {
	v := rv.Interface().(map[uint64]uint64)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeUint(uint64(k2))
		f.ee.encodeUint(uint64(v2))
	}
}

func (f *encFnInfo) fastEncMapIntIntf(rv reflect.Value) {
	v := rv.Interface().(map[int]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapIntString(rv reflect.Value) {
	v := rv.Interface().(map[int]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapIntInt(rv reflect.Value) {
	v := rv.Interface().(map[int]int)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.ee.encodeInt(int64(v2))
	}
}

func (f *encFnInfo) fastEncMapInt8Intf(rv reflect.Value) {
	v := rv.Interface().(map[int8]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapInt8String(rv reflect.Value) {
	v := rv.Interface().(map[int8]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapInt8Int8(rv reflect.Value) {
	v := rv.Interface().(map[int8]int8)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.ee.encodeInt(int64(v2))
	}
}

func (f *encFnInfo) fastEncMapInt16Intf(rv reflect.Value) {
	v := rv.Interface().(map[int16]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapInt16String(rv reflect.Value) {
	v := rv.Interface().(map[int16]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapInt16Int16(rv reflect.Value) {
	v := rv.Interface().(map[int16]int16)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.ee.encodeInt(int64(v2))
	}
}

func (f *encFnInfo) fastEncMapInt32Intf(rv reflect.Value) {
	v := rv.Interface().(map[int32]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.e.encode(k2)
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapInt32String(rv reflect.Value) {
	v := rv.Interface().(map[int32]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.e.encode(k2)
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapInt32Int32(rv reflect.Value) {
	v := rv.Interface().(map[int32]int32)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.e.encode(k2)
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapInt64Intf(rv reflect.Value) {
	v := rv.Interface().(map[int64]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapInt64String(rv reflect.Value) {
	v := rv.Interface().(map[int64]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapInt64Int64(rv reflect.Value) {
	v := rv.Interface().(map[int64]int64)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeInt(int64(k2))
		f.ee.encodeInt(int64(v2))
	}
}

func (f *encFnInfo) fastEncMapBoolIntf(rv reflect.Value) {
	v := rv.Interface().(map[bool]interface{})
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeBool(k2)
		f.e.encode(v2)
	}
}

func (f *encFnInfo) fastEncMapBoolString(rv reflect.Value) {
	v := rv.Interface().(map[bool]string)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeBool(k2)
		f.ee.encodeString(c_UTF8, v2)
	}
}

func (f *encFnInfo) fastEncMapBoolBool(rv reflect.Value) {
	v := rv.Interface().(map[bool]bool)
	f.ee.encodeMapPreamble(len(v))

	for k2, v2 := range v {
		f.ee.encodeBool(k2)
		f.ee.encodeBool(v2)
	}
}

// -- decode

func (f *decFnInfo) fastDecSliceIntf(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]interface{})
	var s []interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]interface{}, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]interface{}, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.d.decode(&s[j])

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceString(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]string)
	var s []string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]string, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]string, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = f.dd.decodeString()

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceFloat32(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]float32)
	var s []float32
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]float32, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]float32, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = float32(f.dd.decodeFloat(true))

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceFloat64(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]float64)
	var s []float64
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]float64, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]float64, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = f.dd.decodeFloat(false)

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceUint(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]uint)
	var s []uint
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]uint, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]uint, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = uint(f.dd.decodeUint(uintBitsize))

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceUint16(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]uint16)
	var s []uint16
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]uint16, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]uint16, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = uint16(f.dd.decodeUint(16))

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceUint32(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]uint32)
	var s []uint32
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]uint32, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]uint32, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = uint32(f.dd.decodeUint(32))

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceUint64(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]uint64)
	var s []uint64
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]uint64, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]uint64, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = f.dd.decodeUint(64)

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceInt(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]int)
	var s []int
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]int, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]int, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = int(f.dd.decodeInt(intBitsize))

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceInt8(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]int8)
	var s []int8
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]int8, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]int8, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = int8(f.dd.decodeInt(8))

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceInt16(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]int16)
	var s []int16
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]int16, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]int16, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = int16(f.dd.decodeInt(16))

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceInt32(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]int32)
	var s []int32
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]int32, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]int32, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = int32(f.dd.decodeInt(32))

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceInt64(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]int64)
	var s []int64
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]int64, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]int64, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = f.dd.decodeInt(64)

	}
	*v = s
}

func (f *decFnInfo) fastDecSliceBool(rv reflect.Value) {
	v := rv.Addr().Interface().(*[]bool)
	var s []bool
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = s
		return
	}

	_, containerLenS := decContLens(f.dd, vtype)
	s = *v
	if s == nil {
		s = make([]bool, containerLenS, containerLenS)
	} else if containerLenS > cap(s) {
		if f.array {
			decErr(msgDecCannotExpandArr, cap(s), containerLenS)
		}
		s = make([]bool, containerLenS, containerLenS)
		copy(s, *v)
	} else if containerLenS > len(s) {
		s = s[:containerLenS]
	}
	for j := 0; j < containerLenS; j++ {
		f.dd.initReadNext()
		s[j] = f.dd.decodeBool()

	}
	*v = s
}

func (f *decFnInfo) fastDecMapIntfIntf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[interface{}]interface{})
	var m map[interface{}]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[interface{}]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		var mk interface{}
		f.d.decode(&mk)
		// special case if a byte array.
		if bv, bok := mk.([]byte); bok {
			mk = string(bv)
		}

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapIntfString(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[interface{}]string)
	var m map[interface{}]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[interface{}]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		var mk interface{}
		f.d.decode(&mk)
		// special case if a byte array.
		if bv, bok := mk.([]byte); bok {
			mk = string(bv)
		}

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapStringIntf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[string]interface{})
	var m map[string]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[string]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeString()

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapStringString(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[string]string)
	var m map[string]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[string]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeString()

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapFloat32Intf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[float32]interface{})
	var m map[float32]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[float32]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := float32(f.dd.decodeFloat(true))

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapFloat32String(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[float32]string)
	var m map[float32]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[float32]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := float32(f.dd.decodeFloat(true))

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapFloat32Float32(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[float32]float32)
	var m map[float32]float32
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[float32]float32, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := float32(f.dd.decodeFloat(true))

		mv := m[mk]
		f.dd.initReadNext()
		mv = float32(f.dd.decodeFloat(true))

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapFloat64Intf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[float64]interface{})
	var m map[float64]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[float64]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeFloat(false)

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapFloat64String(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[float64]string)
	var m map[float64]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[float64]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeFloat(false)

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapFloat64Float64(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[float64]float64)
	var m map[float64]float64
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[float64]float64, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeFloat(false)

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeFloat(false)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUintIntf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint]interface{})
	var m map[uint]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint(f.dd.decodeUint(uintBitsize))

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUintString(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint]string)
	var m map[uint]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint(f.dd.decodeUint(uintBitsize))

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUintUint(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint]uint)
	var m map[uint]uint
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint]uint, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint(f.dd.decodeUint(uintBitsize))

		mv := m[mk]
		f.dd.initReadNext()
		mv = uint(f.dd.decodeUint(uintBitsize))

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint8Intf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint8]interface{})
	var m map[uint8]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint8]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint8(f.dd.decodeUint(8))

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint8String(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint8]string)
	var m map[uint8]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint8]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint8(f.dd.decodeUint(8))

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint8Uint8(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint8]uint8)
	var m map[uint8]uint8
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint8]uint8, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint8(f.dd.decodeUint(8))

		mv := m[mk]
		f.dd.initReadNext()
		mv = uint8(f.dd.decodeUint(8))

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint16Intf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint16]interface{})
	var m map[uint16]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint16]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint16(f.dd.decodeUint(16))

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint16String(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint16]string)
	var m map[uint16]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint16]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint16(f.dd.decodeUint(16))

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint16Uint16(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint16]uint16)
	var m map[uint16]uint16
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint16]uint16, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint16(f.dd.decodeUint(16))

		mv := m[mk]
		f.dd.initReadNext()
		mv = uint16(f.dd.decodeUint(16))

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint32Intf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint32]interface{})
	var m map[uint32]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint32]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint32(f.dd.decodeUint(32))

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint32String(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint32]string)
	var m map[uint32]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint32]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint32(f.dd.decodeUint(32))

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint32Uint32(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint32]uint32)
	var m map[uint32]uint32
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint32]uint32, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := uint32(f.dd.decodeUint(32))

		mv := m[mk]
		f.dd.initReadNext()
		mv = uint32(f.dd.decodeUint(32))

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint64Intf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint64]interface{})
	var m map[uint64]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint64]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeUint(64)

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint64String(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint64]string)
	var m map[uint64]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint64]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeUint(64)

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapUint64Uint64(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[uint64]uint64)
	var m map[uint64]uint64
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[uint64]uint64, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeUint(64)

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeUint(64)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapIntIntf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int]interface{})
	var m map[int]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int(f.dd.decodeInt(intBitsize))

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapIntString(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int]string)
	var m map[int]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int(f.dd.decodeInt(intBitsize))

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapIntInt(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int]int)
	var m map[int]int
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int]int, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int(f.dd.decodeInt(intBitsize))

		mv := m[mk]
		f.dd.initReadNext()
		mv = int(f.dd.decodeInt(intBitsize))

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt8Intf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int8]interface{})
	var m map[int8]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int8]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int8(f.dd.decodeInt(8))

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt8String(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int8]string)
	var m map[int8]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int8]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int8(f.dd.decodeInt(8))

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt8Int8(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int8]int8)
	var m map[int8]int8
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int8]int8, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int8(f.dd.decodeInt(8))

		mv := m[mk]
		f.dd.initReadNext()
		mv = int8(f.dd.decodeInt(8))

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt16Intf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int16]interface{})
	var m map[int16]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int16]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int16(f.dd.decodeInt(16))

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt16String(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int16]string)
	var m map[int16]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int16]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int16(f.dd.decodeInt(16))

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt16Int16(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int16]int16)
	var m map[int16]int16
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int16]int16, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int16(f.dd.decodeInt(16))

		mv := m[mk]
		f.dd.initReadNext()
		mv = int16(f.dd.decodeInt(16))

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt32Intf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int32]interface{})
	var m map[int32]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int32]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int32(f.dd.decodeInt(32))

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt32String(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int32]string)
	var m map[int32]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int32]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int32(f.dd.decodeInt(32))

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt32Int32(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int32]int32)
	var m map[int32]int32
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int32]int32, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := int32(f.dd.decodeInt(32))

		mv := m[mk]
		f.dd.initReadNext()
		mv = int32(f.dd.decodeInt(32))

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt64Intf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int64]interface{})
	var m map[int64]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int64]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeInt(64)

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt64String(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int64]string)
	var m map[int64]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int64]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeInt(64)

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapInt64Int64(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[int64]int64)
	var m map[int64]int64
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[int64]int64, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeInt(64)

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeInt(64)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapBoolIntf(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[bool]interface{})
	var m map[bool]interface{}
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[bool]interface{}, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeBool()

		mv := m[mk]
		f.d.decode(&mv)

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapBoolString(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[bool]string)
	var m map[bool]string
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[bool]string, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeBool()

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeString()

		m[mk] = mv
	}
}

func (f *decFnInfo) fastDecMapBoolBool(rv reflect.Value) {
	v := rv.Addr().Interface().(*map[bool]bool)
	var m map[bool]bool
	vtype := f.dd.currentEncodedType()
	if vtype == valueTypeNil {
		*v = m
		return
	}

	containerLen := f.dd.readMapLen()
	m = *v
	if m == nil {
		m = make(map[bool]bool, containerLen)
		*v = m
	}
	for j := 0; j < containerLen; j++ {
		f.dd.initReadNext()
		mk := f.dd.decodeBool()

		mv := m[mk]
		f.dd.initReadNext()
		mv = f.dd.decodeBool()

		m[mk] = mv
	}
}
